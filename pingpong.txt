library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
-- 移除 std_logic_unsigned，改用 numeric_std 是更現代且標準的作法

entity pingpong is
    Port ( i_clk : in STD_LOGIC;
           i_rst : in STD_LOGIC; -- 假設低位準復位 (Active Low)
           i_swL : in STD_LOGIC;
           i_swR : in STD_LOGIC;
           o_led : out STD_LOGIC_VECTOR (7 downto 0)
           );
end pingpong;

architecture Behavioral of pingpong is
    type STATE_TYPE is (MovingR, MovingL, Lwin, Rwin);
    signal state      : STATE_TYPE;
    signal prev_state : STATE_TYPE;
    signal led_r      : STD_LOGIC_VECTOR (7 downto 0);
    signal scoreL     : unsigned(3 downto 0); -- 改用 unsigned 方便運算
    signal scoreR     : unsigned(3 downto 0);

    signal slow_clk : STD_LOGIC;
    signal cnt      : unsigned(24 downto 0) := (others => '0');

begin
    o_led <= led_r;

    -- 1. 除頻器：修改位元數以獲得肉眼可見的速度
    CLK_DIV: process(i_clk, i_rst)
    begin
        if i_rst = '0' then
            cnt <= (others => '0');
            slow_clk <= '0';
        elsif rising_edge(i_clk) then
            cnt <= cnt + 1;
            -- 修改點：cnt(23) 大約是 0.16 秒跳動一次 (以 50MHz 為例)
            -- 如果覺得太慢，可以改用 cnt(22)；覺得太快改用 cnt(24)
            slow_clk <= cnt(23); 
        end if;
    end process;
        
    -- 2. 狀態機 (FSM)：建議使用系統時鐘 i_clk 確保按鍵反應靈敏
    FSM: process(i_clk, i_rst)
    begin
        if i_rst = '0' then
            state <= MovingR;
        elsif rising_edge(i_clk) then
            case state is
                when MovingR =>
                    -- 修正：判斷球是否漏接 (當 LED 已經到最右邊且沒按按鈕，或太早按)
                    if (led_r = "00000001" and i_swR = '0' and slow_clk = '1') then 
                        -- 這裡邏輯維持原樣，但修正了比較符號的嚴謹性
                        null; 
                    elsif (led_r = "00000000") then -- 球出界
                        state <= Lwin;
                    elsif led_r(0) = '1' and i_swR = '1' then -- 接球成功
                        state <= MovingL;
                    end if;

                when MovingL =>
                    if (led_r = "00000000") then
                        state <= Rwin;
                    elsif led_r(7) = '1' and i_swL = '1' then
                       state <= MovingR;
                    end if;

                when Lwin =>
                    if i_swL = '1' then -- 左方發球
                       state <= MovingR;
                    end if;

                when Rwin =>
                    if i_swR = '1' then -- 右方發球
                       state <= MovingL;
                    end if;
                when others => state <= MovingR;
            end case;
        end if;
    end process;

    -- 3. LED 顯示邏輯
    LED_P: process(slow_clk, i_rst)
    begin
        if i_rst = '0' then
            led_r <= "10000000";
            prev_state <= MovingR;
        elsif rising_edge(slow_clk) then
            prev_state <= state; -- 紀錄上一個狀態
            case state is
                when MovingR =>
                    if (prev_state = Lwin) then
                        led_r <= "10000000"; -- 發球位置
                    else
                        led_r <= '0' & led_r(7 downto 1); -- 右移
                    end if;          

                when MovingL =>
                    if (prev_state = Rwin) then
                        led_r <= "00000001"; -- 發球位置
                    else
                        led_r <= led_r(6 downto 0) & '0'; -- 左移
                    end if;

                when Lwin =>
                    led_r <= "11110000"; -- 左勝閃爍樣式
                when Rwin =>
                    led_r <= "00001111"; -- 右勝閃爍樣式
                when others => null;
            end case;    
        end if;
    end process;

    -- 4. 計分邏輯 (合併簡化)
    Score_Process: process(state, i_rst)
    begin
        if i_rst = '0' then
            scoreL <= (others => '0');
            scoreR <= (others => '0');
        elsif rising_edge(i_clk) then
            -- 僅在進入勝利狀態的一瞬間加分
            if state = Lwin and prev_state = MovingR then
                scoreL <= scoreL + 1;
            elsif state = Rwin and prev_state = MovingL then
                scoreR <= scoreR + 1;
            end if;
        end if;
    end process;

end Behavioral;